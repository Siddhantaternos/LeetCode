# 3Sum — Clean Short Notes (Interview Ready)

## Goal

Find **all unique triplets** in the array whose sum is **0**.
No duplicate triplets allowed.

---

## Core Pattern

**Sort + Fix one element + Two pointers**

This is a **pattern problem**, not a math problem.

---

## Why Sorting Is Mandatory

* Enables **two-pointer technique**
* Guarantees duplicates are **adjacent**
* Allows controlled pointer movement (increase / decrease sum)

---

## Step-by-Step Strategy

### 1. Sort the array

Brings order and structure.

---

### 2. Fix one element (`i`)

Loop through the array and treat `nums[i]` as the **first element** of the triplet.

---

### 3. Skip duplicates for `i`

If current element is same as previous, skip it to avoid repeated triplets.

---

### 4. Two pointers on remaining array

* `left = i + 1`
* `right = last index`

---

### 5. Adjust pointers based on sum

| Condition | Action                          |
| --------- | ------------------------------- |
| sum < 0   | Move `left` right               |
| sum > 0   | Move `right` left               |
| sum = 0   | Store triplet + skip duplicates |

---

### 6. Skip duplicates after finding a valid triplet

Move pointers until values change.

---

## Highlighted Code (Clean & Slightly Different)

```python
from typing import List

class Solution:
    def threeSum(self, nums: List[int]) -> List[List[int]]:
        nums.sort()
        ans = []
        n = len(nums)

        for i in range(n - 2):
            if i > 0 and nums[i] == nums[i - 1]:
                continue

            left, right = i + 1, n - 1

            while left < right:
                total = nums[i] + nums[left] + nums[right]

                if total == 0:
                    ans.append([nums[i], nums[left], nums[right]])
                    left += 1
                    right -= 1

                    while left < right and nums[left] == nums[left - 1]:
                        left += 1
                    while left < right and nums[right] == nums[right + 1]:
                        right -= 1

                elif total < 0:
                    left += 1
                else:
                    right -= 1

        return ans
```

---

## Complexity

* **Time:** `O(n²)`
* **Space:** `O(1)` (output excluded)

---

## Mental Model (Important)

* Sorting gives **direction**
* Left pointer → increases sum
* Right pointer → decreases sum
* Duplicates are skipped **at every decision layer**

---

## Interview Signal

* If you understand **why pointers move**, you understand 3Sum
* If you only remember syntax, you don’t

---

## Pattern Expansion

* **2Sum** → Hash / Two pointers
* **3Sum** → Fix one + Two pointers
* **4Sum** → Fix two + Two pointers

Same brain, more control.

