## ğŸ§  Problem Core (Human Version)

You have three numbers: `a`, `b`, `c`.

You can flip any bit in `a` or `b`.

Goal:
Make `(a OR b) == c`
Using **minimum flips**.

A flip = change `0 â†’ 1` or `1 â†’ 0` in binary.

The OR operation means:

* If either bit is `1`, result is `1`
* Only `0 OR 0 = 0`

Each bit position is independent â†’ so solve bit-by-bit.

Flip operations are simply changing individual bits of `a` or `b` so that their OR matches `c`. ([cn.julialang.org][1])

If a bit is `1` in `a` or `b` but must be `0` in result, you may need one or two flips. ([docs.vultr.com][2])

---

## ğŸ”¬ Bit Logic Truth Table

For each bit:

| a | b | c | Needed Action     |
| - | - | - | ----------------- |
| 0 | 0 | 0 | OK                |
| 0 | 0 | 1 | Flip one (a or b) |
| 1 | 0 | 0 | Flip a            |
| 0 | 1 | 0 | Flip b            |
| 1 | 1 | 0 | Flip BOTH         |
| 1 | 1 | 1 | OK                |

---

## âš™ï¸ Optimal Thinking

Loop through 32 bits (int size).
For each bit:

If `c bit = 1`
â†’ At least one of `a` or `b` must be 1
â†’ If both 0 â†’ need 1 flip

If `c bit = 0`
â†’ Both must be 0
â†’ Count how many are 1 â†’ flips needed

---

## ğŸ’» C++ Code (LeetCode Ready)

```cpp
class Solution {
public:
    int minFlips(int a, int b, int c) {
        int flips = 0;

        for (int i = 0; i < 32; i++) {
            int bitA = (a >> i) & 1;
            int bitB = (b >> i) & 1;
            int bitC = (c >> i) & 1;

            if (bitC == 1) {
                // Need at least one 1 in a or b
                if (bitA == 0 && bitB == 0)
                    flips += 1;
            } else {
                // Need both 0
                flips += bitA + bitB;
            }
        }

        return flips;
    }
};
```

---

## â± Complexity

Time â†’ `O(32)` â†’ Constant
Space â†’ `O(1)`

Basically free performance-wise.

---

## ğŸ§  Mental Model

Think like hardware:

You are repairing a broken circuit.
Each bit = one wire.
You fix wires individually.

---

## Brutal Reality Check

If you try solving this using decimal logic â†’ youâ€™re wasting brain cycles.
This is a **bit manipulation pattern recognition** problem.

If you understand:

* shifting
* masking
* OR truth table

Then this becomes trivial.

---

